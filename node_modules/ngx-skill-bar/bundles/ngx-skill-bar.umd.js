(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-skill-bar', ['exports', '@angular/core', '@angular/common'], factory) :
    (factory((global['ngx-skill-bar'] = {}),global.ng.core,global.ng.common));
}(this, (function (exports,core,common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Bar = (function () {
        function Bar(width) {
            if (width === void 0) {
                width = 100;
            }
            this.width = width;
        }
        return Bar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NgxSkillBarComponent = (function () {
        function NgxSkillBarComponent() {
            this.percentage = 0;
            this.numberOfBars = 5;
            this.standarWidthBar = 20;
        }
        /**
         * @return {?}
         */
        NgxSkillBarComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.init();
            };
        /**
         * @return {?}
         */
        NgxSkillBarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.init();
            };
        /**
         * @return {?}
         */
        NgxSkillBarComponent.prototype.init = /**
         * @return {?}
         */
            function () {
                this.standarWidthBar = 100 / this.numberOfBars;
                this.bars = __spread(this.generateLine());
            };
        /**
         * @return {?}
         */
        NgxSkillBarComponent.prototype.generateLine = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ bars = [];
                for (var /** @type {?} */ i = 1; i <= this.numberOfBars; i++) {
                    bars = __spread(bars, [new Bar(this.calculateBar(i))]);
                }
                return bars;
            };
        /**
         * @param {?} indexBar
         * @return {?}
         */
        NgxSkillBarComponent.prototype.calculateBar = /**
         * @param {?} indexBar
         * @return {?}
         */
            function (indexBar) {
                var /** @type {?} */ substraction = this.percentage - (indexBar - 1) * this.standarWidthBar;
                if (this.percentage >= indexBar * this.standarWidthBar) {
                    return 100;
                }
                else if (substraction > 0) {
                    return (substraction * 100) / this.standarWidthBar;
                }
                return 0;
            };
        NgxSkillBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-skill-bar",
                        template: "\n    <statistics-list-bar [full]=\"full\" [barWidth]=\"barWidth\" [showFigures]=\"showFigures\" [percentage]=\"percentage\" [bars]=\"bars\" [bgColor]=\"bgColor\" [color]=\"color\"></statistics-list-bar>\n  ",
                        styles: []
                    },] },
        ];
        /** @nocollapse */
        NgxSkillBarComponent.ctorParameters = function () { return []; };
        NgxSkillBarComponent.propDecorators = {
            percentage: [{ type: core.Input }],
            numberOfBars: [{ type: core.Input }],
            showFigures: [{ type: core.Input }],
            bgColor: [{ type: core.Input }],
            color: [{ type: core.Input }],
            barWidth: [{ type: core.Input }],
            full: [{ type: core.Input }]
        };
        return NgxSkillBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StatisticsBarComponent = (function () {
        function StatisticsBarComponent(cdr) {
            this.cdr = cdr;
            this.width = 0;
            this.bgColor = "#644d4d";
            this.color = "white";
            this.barWidth = 40;
        }
        /**
         * @return {?}
         */
        StatisticsBarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () { };
        /**
         * @return {?}
         */
        StatisticsBarComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () { };
        StatisticsBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "statistics-bar",
                        template: "<div class=\"bar\" \n  [ngStyle]=\"{'background-color': bgColor, 'width': barWidth+'px'}\">\n  <div [ngStyle]=\"{'width': width+'%', 'background-color': color}\"></div>\n</div>",
                        styles: [".bar{background-color:#644d4d;height:9px;width:40px}.bar>div{background-color:#fff;height:9px}"]
                    },] },
        ];
        /** @nocollapse */
        StatisticsBarComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        StatisticsBarComponent.propDecorators = {
            width: [{ type: core.Input }],
            bgColor: [{ type: core.Input }],
            color: [{ type: core.Input }],
            barWidth: [{ type: core.Input }]
        };
        return StatisticsBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DEFAULT_PADDING = 2;
    var StatisticsListBarComponent = (function () {
        function StatisticsListBarComponent() {
            this.bars = [];
            this.showFigures = false;
            this.percentage = 0;
            this.full = false;
            this.padding = DEFAULT_PADDING;
        }
        /**
         * @return {?}
         */
        StatisticsListBarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.full == true) {
                    this.padding = 0;
                }
                else {
                    this.padding = DEFAULT_PADDING;
                }
            };
        /**
         * @return {?}
         */
        StatisticsListBarComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () { };
        StatisticsListBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "statistics-list-bar",
                        template: "<div class=\"statistics-container\">\n    <statistics-bar \n        class=\"statistics-item\" \n        *ngFor=\"let bar of bars\"  \n        [width]=\"bar.width\" \n        [bgColor]=\"bgColor\" \n        [color]=\"color\" \n        [barWidth]=\"barWidth\"\n        [ngStyle]=\"{'padding': padding+'px'}\"\n        ></statistics-bar>\n    <div class=\"figures\" *ngIf=\"showFigures\">{{percentage}}%</div>\n</div>\n",
                        styles: [".statistics-container{display:flex;flex-wrap:wrap}.statistics-item{margin-top:1px;padding:2px}.figures{margin-top:-4px;margin-left:4px}"]
                    },] },
        ];
        /** @nocollapse */
        StatisticsListBarComponent.ctorParameters = function () { return []; };
        StatisticsListBarComponent.propDecorators = {
            bars: [{ type: core.Input }],
            showFigures: [{ type: core.Input }],
            percentage: [{ type: core.Input }],
            bgColor: [{ type: core.Input }],
            color: [{ type: core.Input }],
            barWidth: [{ type: core.Input }],
            full: [{ type: core.Input }]
        };
        return StatisticsListBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NgxSkillBarModule = (function () {
        function NgxSkillBarModule() {
        }
        NgxSkillBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [
                            NgxSkillBarComponent,
                            StatisticsBarComponent,
                            StatisticsListBarComponent
                        ],
                        exports: [NgxSkillBarComponent]
                    },] },
        ];
        return NgxSkillBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.NgxSkillBarComponent = NgxSkillBarComponent;
    exports.NgxSkillBarModule = NgxSkillBarModule;
    exports.ɵa = StatisticsBarComponent;
    exports.ɵb = StatisticsListBarComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXNraWxsLWJhci51bWQuanMubWFwIiwic291cmNlcyI6W251bGwsIm5nOi8vbmd4LXNraWxsLWJhci9saWIvYmFyLm1vZGVsLnRzIiwibmc6Ly9uZ3gtc2tpbGwtYmFyL2xpYi9uZ3gtc2tpbGwtYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LXNraWxsLWJhci9saWIvc3RhdGlzdGljcy1iYXIvc3RhdGlzdGljcy1iYXIuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtc2tpbGwtYmFyL2xpYi9zdGF0aXN0aWNzLWxpc3QtYmFyL3N0YXRpc3RpY3MtbGlzdC1iYXIuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtc2tpbGwtYmFyL2xpYi9uZ3gtc2tpbGwtYmFyLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImV4cG9ydCBjbGFzcyBCYXIge1xuICB3aWR0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHdpZHRoOiBudW1iZXIgPSAxMDApIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT25DaGFuZ2VzIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEJhciB9IGZyb20gXCIuL2Jhci5tb2RlbFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwibmd4LXNraWxsLWJhclwiLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdGF0aXN0aWNzLWxpc3QtYmFyIFtmdWxsXT1cImZ1bGxcIiBbYmFyV2lkdGhdPVwiYmFyV2lkdGhcIiBbc2hvd0ZpZ3VyZXNdPVwic2hvd0ZpZ3VyZXNcIiBbcGVyY2VudGFnZV09XCJwZXJjZW50YWdlXCIgW2JhcnNdPVwiYmFyc1wiIFtiZ0NvbG9yXT1cImJnQ29sb3JcIiBbY29sb3JdPVwiY29sb3JcIj48L3N0YXRpc3RpY3MtbGlzdC1iYXI+XG4gIGAsXG4gIHN0eWxlczogW11cbn0pXG5leHBvcnQgY2xhc3MgTmd4U2tpbGxCYXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIHBlcmNlbnRhZ2U6IG51bWJlciA9IDA7XG4gIEBJbnB1dCgpIG51bWJlck9mQmFycyA9IDU7XG4gIEBJbnB1dCgpIHNob3dGaWd1cmVzOiBib29sZWFuO1xuICBASW5wdXQoKSBiZ0NvbG9yOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGJhcldpZHRoOiBudW1iZXI7XG4gIEBJbnB1dCgpIGZ1bGw6IGJvb2xlYW47XG5cbiAgc3RhbmRhcldpZHRoQmFyOiBudW1iZXIgPSAyMDtcbiAgYmFyczogQmFyW107XG5cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuc3RhbmRhcldpZHRoQmFyID0gMTAwIC8gdGhpcy5udW1iZXJPZkJhcnM7XG4gICAgdGhpcy5iYXJzID0gWy4uLnRoaXMuZ2VuZXJhdGVMaW5lKCldO1xuICB9XG5cbiAgZ2VuZXJhdGVMaW5lKCkge1xuICAgIGxldCBiYXJzOiBCYXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMubnVtYmVyT2ZCYXJzOyBpKyspIHtcbiAgICAgIGJhcnMgPSBbLi4uYmFycywgbmV3IEJhcih0aGlzLmNhbGN1bGF0ZUJhcihpKSldO1xuICAgIH1cbiAgICByZXR1cm4gYmFycztcbiAgfVxuXG4gIGNhbGN1bGF0ZUJhcihpbmRleEJhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBzdWJzdHJhY3Rpb24gPVxuICAgICAgdGhpcy5wZXJjZW50YWdlIC0gKGluZGV4QmFyIC0gMSkgKiB0aGlzLnN0YW5kYXJXaWR0aEJhcjtcbiAgICBpZiAodGhpcy5wZXJjZW50YWdlID49IGluZGV4QmFyICogdGhpcy5zdGFuZGFyV2lkdGhCYXIpIHtcbiAgICAgIHJldHVybiAxMDA7XG4gICAgfSBlbHNlIGlmIChzdWJzdHJhY3Rpb24gPiAwKSB7XG4gICAgICByZXR1cm4gKHN1YnN0cmFjdGlvbiAqIDEwMCkgLyB0aGlzLnN0YW5kYXJXaWR0aEJhcjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT25DaGFuZ2VzLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgT25Jbml0LFxuICBJbnB1dFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwic3RhdGlzdGljcy1iYXJcIixcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiYmFyXCIgXG4gIFtuZ1N0eWxlXT1cInsnYmFja2dyb3VuZC1jb2xvcic6IGJnQ29sb3IsICd3aWR0aCc6IGJhcldpZHRoKydweCd9XCI+XG4gIDxkaXYgW25nU3R5bGVdPVwieyd3aWR0aCc6IHdpZHRoKyclJywgJ2JhY2tncm91bmQtY29sb3InOiBjb2xvcn1cIj48L2Rpdj5cbjwvZGl2PmAsXG4gIHN0eWxlczogW2AuYmFye2JhY2tncm91bmQtY29sb3I6IzY0NGQ0ZDtoZWlnaHQ6OXB4O3dpZHRoOjQwcHh9LmJhcj5kaXZ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2hlaWdodDo5cHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgU3RhdGlzdGljc0JhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgd2lkdGg6IG51bWJlciA9IDA7XG4gIEBJbnB1dCgpIGJnQ29sb3I6IHN0cmluZyA9IFwiIzY0NGQ0ZFwiO1xuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nID0gXCJ3aGl0ZVwiO1xuICBASW5wdXQoKSBiYXJXaWR0aDogbnVtYmVyID0gNDA7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIG5nT25Jbml0KCkge31cblxuICBuZ09uQ2hhbmdlcygpIHt9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgT25DaGFuZ2VzLCBJbnB1dCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBCYXIgfSBmcm9tIFwiLi4vYmFyLm1vZGVsXCI7XG5cbmNvbnN0IERFRkFVTFRfUEFERElORzogbnVtYmVyID0gMjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN0YXRpc3RpY3MtbGlzdC1iYXJcIixcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic3RhdGlzdGljcy1jb250YWluZXJcIj5cbiAgICA8c3RhdGlzdGljcy1iYXIgXG4gICAgICAgIGNsYXNzPVwic3RhdGlzdGljcy1pdGVtXCIgXG4gICAgICAgICpuZ0Zvcj1cImxldCBiYXIgb2YgYmFyc1wiICBcbiAgICAgICAgW3dpZHRoXT1cImJhci53aWR0aFwiIFxuICAgICAgICBbYmdDb2xvcl09XCJiZ0NvbG9yXCIgXG4gICAgICAgIFtjb2xvcl09XCJjb2xvclwiIFxuICAgICAgICBbYmFyV2lkdGhdPVwiYmFyV2lkdGhcIlxuICAgICAgICBbbmdTdHlsZV09XCJ7J3BhZGRpbmcnOiBwYWRkaW5nKydweCd9XCJcbiAgICAgICAgPjwvc3RhdGlzdGljcy1iYXI+XG4gICAgPGRpdiBjbGFzcz1cImZpZ3VyZXNcIiAqbmdJZj1cInNob3dGaWd1cmVzXCI+e3twZXJjZW50YWdlfX0lPC9kaXY+XG48L2Rpdj5cbmAsXG4gIHN0eWxlczogW2Auc3RhdGlzdGljcy1jb250YWluZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwfS5zdGF0aXN0aWNzLWl0ZW17bWFyZ2luLXRvcDoxcHg7cGFkZGluZzoycHh9LmZpZ3VyZXN7bWFyZ2luLXRvcDotNHB4O21hcmdpbi1sZWZ0OjRweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBTdGF0aXN0aWNzTGlzdEJhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25Jbml0IHtcbiAgQElucHV0KCkgYmFyczogQmFyW10gPSBbXTtcbiAgQElucHV0KCkgc2hvd0ZpZ3VyZXM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgcGVyY2VudGFnZTogbnVtYmVyID0gMDtcbiAgQElucHV0KCkgYmdDb2xvcjogc3RyaW5nO1xuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nO1xuICBASW5wdXQoKSBiYXJXaWR0aDogbnVtYmVyO1xuICBASW5wdXQoKSBmdWxsOiBib29sZWFuID0gZmFsc2U7XG4gIHBhZGRpbmc6IG51bWJlciA9IERFRkFVTFRfUEFERElORztcblxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMuZnVsbCA9PSB0cnVlKSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSBERUZBVUxUX1BBRERJTkc7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoKSB7fVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHsgTmd4U2tpbGxCYXJDb21wb25lbnQgfSBmcm9tIFwiLi9uZ3gtc2tpbGwtYmFyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgU3RhdGlzdGljc0JhckNvbXBvbmVudCB9IGZyb20gXCIuL3N0YXRpc3RpY3MtYmFyL3N0YXRpc3RpY3MtYmFyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgU3RhdGlzdGljc0xpc3RCYXJDb21wb25lbnQgfSBmcm9tIFwiLi9zdGF0aXN0aWNzLWxpc3QtYmFyL3N0YXRpc3RpY3MtbGlzdC1iYXIuY29tcG9uZW50XCI7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBOZ3hTa2lsbEJhckNvbXBvbmVudCxcbiAgICBTdGF0aXN0aWNzQmFyQ29tcG9uZW50LFxuICAgIFN0YXRpc3RpY3NMaXN0QmFyQ29tcG9uZW50XG4gIF0sXG4gIGV4cG9ydHM6IFtOZ3hTa2lsbEJhckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgTmd4U2tpbGxCYXJNb2R1bGUge31cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJJbnB1dCIsIkNoYW5nZURldGVjdG9yUmVmIiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7OztBQWNBLG9CQXVHdUIsQ0FBQyxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsT0FBTyxNQUFNLEtBQUssVUFBVSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLENBQUM7WUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNqQyxJQUFJO1lBQ0EsT0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsSUFBSTtnQkFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM5RTtRQUNELE9BQU8sS0FBSyxFQUFFO1lBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDO1NBQUU7Z0JBQy9CO1lBQ0osSUFBSTtnQkFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3BEO29CQUNPO2dCQUFFLElBQUksQ0FBQztvQkFBRSxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUM7YUFBRTtTQUNwQztRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztBQUVEO1FBQ0ksS0FBSyxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7WUFDOUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsT0FBTyxFQUFFLENBQUM7SUFDZCxDQUFDOzs7Ozs7SUMxSUQsSUFBQTtRQUdFLGFBQVksS0FBbUI7WUFBbkIsc0JBQUE7Z0JBQUEsV0FBbUI7O1lBQzdCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1NBQ3BCO2tCQUxIO1FBTUMsQ0FBQTs7Ozs7OztRQ2dCQzs4QkFYOEIsQ0FBQztnQ0FDUCxDQUFDO21DQU9DLEVBQUU7U0FHWjs7OztRQUVoQiwwQ0FBVzs7O1lBQVg7Z0JBQ0UsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ2I7Ozs7UUFFRCx1Q0FBUTs7O1lBQVI7Z0JBQ0UsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ2I7Ozs7UUFFRCxtQ0FBSTs7O1lBQUo7Z0JBQ0UsSUFBSSxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFDL0MsSUFBSSxDQUFDLElBQUksWUFBTyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQzthQUN0Qzs7OztRQUVELDJDQUFZOzs7WUFBWjtnQkFDRSxxQkFBSSxJQUFJLEdBQVUsRUFBRSxDQUFDO2dCQUNyQixLQUFLLHFCQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQzNDLElBQUksWUFBTyxJQUFJLEdBQUUsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUM7aUJBQ2pEO2dCQUNELE9BQU8sSUFBSSxDQUFDO2FBQ2I7Ozs7O1FBRUQsMkNBQVk7Ozs7WUFBWixVQUFhLFFBQWdCO2dCQUMzQixxQkFBTSxZQUFZLEdBQ2hCLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUM7Z0JBQzFELElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRTtvQkFDdEQsT0FBTyxHQUFHLENBQUM7aUJBQ1o7cUJBQU0sSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUFFO29CQUMzQixPQUFPLENBQUMsWUFBWSxHQUFHLEdBQUcsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDO2lCQUNwRDtnQkFDRCxPQUFPLENBQUMsQ0FBQzthQUNWOztvQkFuREZBLGNBQVMsU0FBQzt3QkFDVCxRQUFRLEVBQUUsZUFBZTt3QkFDekIsUUFBUSxFQUFFLGlOQUVUO3dCQUNELE1BQU0sRUFBRSxFQUFFO3FCQUNYOzs7OztpQ0FFRUMsVUFBSzttQ0FDTEEsVUFBSztrQ0FDTEEsVUFBSzs4QkFDTEEsVUFBSzs0QkFDTEEsVUFBSzsrQkFDTEEsVUFBSzsyQkFDTEEsVUFBSzs7bUNBakJSOzs7Ozs7O0FDQUE7UUFzQkUsZ0NBQW9CLEdBQXNCO1lBQXRCLFFBQUcsR0FBSCxHQUFHLENBQW1CO3lCQUxqQixDQUFDOzJCQUNDLFNBQVM7eUJBQ1gsT0FBTzs0QkFDSixFQUFFO1NBRWdCOzs7O1FBRTlDLHlDQUFROzs7WUFBUixlQUFhOzs7O1FBRWIsNENBQVc7OztZQUFYLGVBQWdCOztvQkFsQmpCRCxjQUFTLFNBQUM7d0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjt3QkFDMUIsUUFBUSxFQUFFLGtMQUdMO3dCQUNMLE1BQU0sRUFBRSxDQUFDLGdHQUFnRyxDQUFDO3FCQUMzRzs7Ozs7d0JBWkNFLHNCQUFpQjs7Ozs0QkFjaEJELFVBQUs7OEJBQ0xBLFVBQUs7NEJBQ0xBLFVBQUs7K0JBQ0xBLFVBQUs7O3FDQXBCUjs7Ozs7OztBQ0FBLElBR0EscUJBQU0sZUFBZSxHQUFXLENBQUMsQ0FBQzs7UUE2QmhDO3dCQVR1QixFQUFFOytCQUNPLEtBQUs7OEJBQ1AsQ0FBQzt3QkFJTixLQUFLOzJCQUNaLGVBQWU7U0FFakI7Ozs7UUFFaEIsNkNBQVE7OztZQUFSO2dCQUNFLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7b0JBQ3JCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO2lCQUNsQjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQztpQkFDaEM7YUFDRjs7OztRQUVELGdEQUFXOzs7WUFBWCxlQUFnQjs7b0JBckNqQkQsY0FBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxxQkFBcUI7d0JBQy9CLFFBQVEsRUFBRSxrYUFZWDt3QkFDQyxNQUFNLEVBQUUsQ0FBQyx5SUFBeUksQ0FBQztxQkFDcEo7Ozs7OzJCQUVFQyxVQUFLO2tDQUNMQSxVQUFLO2lDQUNMQSxVQUFLOzhCQUNMQSxVQUFLOzRCQUNMQSxVQUFLOytCQUNMQSxVQUFLOzJCQUNMQSxVQUFLOzt5Q0E3QlI7Ozs7Ozs7QUNBQTs7OztvQkFNQ0UsYUFBUSxTQUFDO3dCQUNSLE9BQU8sRUFBRSxDQUFDQyxtQkFBWSxDQUFDO3dCQUN2QixZQUFZLEVBQUU7NEJBQ1osb0JBQW9COzRCQUNwQixzQkFBc0I7NEJBQ3RCLDBCQUEwQjt5QkFDM0I7d0JBQ0QsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUM7cUJBQ2hDOztnQ0FkRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=